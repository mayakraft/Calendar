<!DOCTYPE html>
<title></title>
<style>
html,body{ height:100%; }
body{
	margin: 0;
	background-color: black;
	display: flex;
	align-items: center;
	justify-content: center;
}
svg{
	width: 90vmin;
	height: 90vmin;
}
</style>
<script type="text/javascript" src="../svg.js"></script>
<script type="" src="load-csv.js"></script>

<script>
let w = 700;
let h = 700;
let sketch = SVG.View(w, h);
sketch.onMouseDown = function(){ sketch.download(); }

loadCSV("2019.csv", function(data){

	let planetNames = ["Mercury", "Venus", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune", "Pluto"];
	let moonEventAngles = [0.0, Math.PI*0.5, Math.PI, Math.PI*1.5];
	let moonEventDescriptions = ["New", "First Quarter", "Full", "Third Quarter"];
	let zodiacNames = ["Capricorn", "Aquarius", "Pisces", "Aries", "Taurus", "Gemini", "Cancer", "Leo", "Virgo", "Libra", "Scorpio", "Sagittarius"];

	let year = data.map(d => d["year"]);
	let month = data.map(d => d["month"]);
	let day = data.map(d => d["day"]);
	let hour = data.map(d => d["hour"]);
	let minute = data.map(d => d["minute"]);
	let second = data.map(d => d["second"]);
	let sunLongitude = data.map(d => d["sunLongitude"] / 180 * Math.PI);
	let sunDistance = data.map(d => d["sunDistance"]);
	let zodiac = data.map(d => d["zodiac"]);
	let daylight = data.map(d => d["daylight"]);
	let mercuryLongitude = data.map(d => d["mercuryLongitude"] / 180 * Math.PI);
	let mercuryLatitude = data.map(d => d["mercuryLatitude"] / 180 * Math.PI);
	let mercuryDistance = data.map(d => d["mercuryDistance"]);
	let venusLongitude = data.map(d => d["venusLongitude"] / 180 * Math.PI);
	let venusLatitude = data.map(d => d["venusLatitude"] / 180 * Math.PI);
	let venusDistance = data.map(d => d["venusDistance"]);
	let marsLongitude = data.map(d => d["marsLongitude"] / 180 * Math.PI);
	let marsLatitude = data.map(d => d["marsLatitude"] / 180 * Math.PI);
	let marsDistance = data.map(d => d["marsDistance"]);
	let jupiterLongitude = data.map(d => d["jupiterLongitude"] / 180 * Math.PI);
	let jupiterLatitude = data.map(d => d["jupiterLatitude"] / 180 * Math.PI);
	let jupiterDistance = data.map(d => d["jupiterDistance"]);
	let saturnLongitude = data.map(d => d["saturnLongitude"] / 180 * Math.PI);
	let saturnLatitude = data.map(d => d["saturnLatitude"] / 180 * Math.PI);
	let saturnDistance = data.map(d => d["saturnDistance"]);
	let uranusLongitude = data.map(d => d["uranusLongitude"] / 180 * Math.PI);
	let uranusLatitude = data.map(d => d["uranusLatitude"] / 180 * Math.PI);
	let uranusDistance = data.map(d => d["uranusDistance"]);
	let neptuneLongitude = data.map(d => d["neptuneLongitude"] / 180 * Math.PI);
	let neptuneLatitude = data.map(d => d["neptuneLatitude"] / 180 * Math.PI);
	let neptuneDistance = data.map(d => d["neptuneDistance"]);
	let plutoLongitude = data.map(d => d["plutoLongitude"] / 180 * Math.PI);
	let plutoLatitude = data.map(d => d["plutoLatitude"] / 180 * Math.PI);
	let plutoDistance = data.map(d => d["plutoDistance"]);
	let moonLongitude = data.map(d => d["moonLongitude"] / 180 * Math.PI);
	let moonLatitude = data.map(d => d["moonLatitude"] / 180 * Math.PI);
	let moonDistance = data.map(d => d["moonDistance"]);
	let moonPhase = data.map(d => d["moonPhase"] / 180 * Math.PI);

	let planets = [
		{name: "Mercury", longitude: mercuryLongitude, distance: mercuryDistance,
			color: "rgb(192,192,192)"},
		{name: "Venus", longitude: venusLongitude, distance: venusDistance,
			color: "rgb(206,172,113)"},
		{name: "Mars", longitude: marsLongitude, distance: marsDistance,
			color: "rgb(172,81,40)"},
		{name: "Jupiter", longitude: jupiterLongitude, distance: jupiterDistance,
			color: "rgb(186,130,83)"},
		{name: "Saturn", longitude: saturnLongitude, distance: saturnDistance,
			color: "rgb(253,196,126)"},
		{name: "Uranus", longitude: uranusLongitude, distance: uranusDistance,
			color: "rgb(149,188,198)"},
		{name: "Neptune", longitude: neptuneLongitude, distance: neptuneDistance,
			color: "rgb(98,119,226)"},
		{name: "Pluto", longitude: plutoLongitude, distance: plutoDistance,
			color: "rgb(169,149,146)"}
	];

	// translate(width*0.5, height*0.5);
	// rotate(-1.0/24.0*Math.PI*2);

	let innerR = 100;
	let outerR = 280;

	let backRect = SVG.rect(0, 0, w, h);
	SVG.setAttribute(backRect, "fill", "white");
	sketch.appendChild(backRect);

	let layer = SVG.group();
	SVG.setAttribute(layer, "id", "transform-layer");
	let translateString = "translate(" + (w*0.5) + " " + (h*0.5) + ")";
	let rotateString = 	"rotate(" + (-1/24*360) +")";
	let reflectString = "scale(-1 1)";
	let transform = [translateString, reflectString, rotateString].join(" ");
	SVG.setAttribute(layer, "transform", transform);
	sketch.appendChild(layer);

	let noTiltLayer = SVG.group();
	SVG.setAttribute(noTiltLayer, "transform", translateString);
	sketch.appendChild(noTiltLayer);

	let gridLayer = SVG.group();
	let moonLayer = SVG.group();
	let sunLayer = SVG.group();
	let planetsLayer = SVG.group();
	let dataLayer = SVG.group();
	let textLayer = SVG.group();
	SVG.setAttribute(gridLayer, "id", "grid");
	SVG.setAttribute(moonLayer, "id", "moon");
	SVG.setAttribute(sunLayer, "id", "sun");
	SVG.setAttribute(planetsLayer, "id", "planets");
	SVG.setAttribute(dataLayer, "id", "data");
	SVG.setAttribute(textLayer, "id", "text");
	layer.appendChild(sunLayer);
	layer.appendChild(gridLayer);
	layer.appendChild(moonLayer);
	layer.appendChild(planetsLayer);
	layer.appendChild(dataLayer);
	sketch.appendChild(textLayer);

	SVG.setAttribute(textLayer, "transform", [translateString, rotateString].join(" "));
	sketch.appendChild(textLayer);

	// outer measurement lines
	Array.from(Array(960)).forEach((_,i) =>{
		let r2, a = i / 960 * Math.PI*2;
		if      (i % 16 == 0){ r2 = outerR + 10;    }
		else if (i % 8 == 0) { r2 = outerR + 6.66;  }
		else if (i % 4 == 0) { r2 = outerR + 4.444; }
		else if (i % 2 == 0) { r2 = outerR + 2.888; }
		else                 { r2 = outerR + 1.9;   }
		let l = SVG.line(
			Math.cos(a)*outerR,
			Math.sin(a)*outerR,
			Math.cos(a)*r2,
			Math.sin(a)*r2);
		SVG.setAttribute(l, "stroke", "#777");
		gridLayer.appendChild(l);
	});
	// // 12 month-dividing circles
	// for(let i = 12; i >= 0; i--){
	// 	let r = innerR + (outerR-innerR) * i/12.0;
	// 	let circle = SVG.circle(0, 0, r);
	// 	SVG.setAttribute(circle, "stroke", "#fff");
	// 	SVG.setAttribute(circle, "fill", "none");
	// 	gridLayer.appendChild(circle);
	// }
	// 12 zodiac-dividing lines
	for(let i = 0; i < Math.PI*2; i += Math.PI*2/12 ){
		let l = SVG.line(Math.cos(i)*innerR, Math.sin(i)*innerR, Math.cos(i)*outerR, Math.sin(i)*outerR);
		SVG.setAttribute(l, "stroke", "#777")
		gridLayer.appendChild(l);
	}

	// draw moon
	for(let i = 1; i < moonLongitude.length; i++) {
		let calendarR = innerR + (outerR-innerR) * i / moonLongitude.length;
		let lastCalendarR = innerR + (outerR-innerR) * (i-1) / moonLongitude.length;
		let phase0_1 = Math.cos(moonPhase[i])*0.5+0.5;
		let moonLine = SVG.line(
			Math.cos(moonLongitude[i-1])*lastCalendarR,
			Math.sin(moonLongitude[i-1])*lastCalendarR,
			Math.cos(moonLongitude[i])*calendarR,
			Math.sin(moonLongitude[i])*calendarR
		);
		// let gray = 255 - phase0_1 * (255-33) + 33;
		// let gray = phase0_1 * (200-20) + 20;
		let gray = phase0_1 * (60-20) + 180;
		SVG.setAttribute(moonLine, "stroke-width", 6 - phase0_1*5.5);
		// SVG.setAttribute(moonLine, "stroke-width", 3 - phase0_1*3);
		// SVG.setAttribute(moonLine, "stroke", "rgb("+gray+","+gray+","+gray+")");
		SVG.setAttribute(moonLine, "stroke", "rgb(0,0,0)");
		SVG.setAttribute(moonLine, "stroke-linecap", "round");
		moonLayer.appendChild(moonLine);
	}

	// draw sun
	for(let i = 1; i < sunLongitude.length; i++) {
		let calendarR = innerR + (outerR-innerR) * i / sunLongitude.length;
		let lastCalendarR = innerR + (outerR-innerR) * (i-1) / sunLongitude.length;
		let sunLine = SVG.line(
			Math.cos(sunLongitude[i-1]) * lastCalendarR,
			Math.sin(sunLongitude[i-1]) * lastCalendarR,
			Math.cos(sunLongitude[i])*calendarR,
			Math.sin(sunLongitude[i])*calendarR
		);
		// SVG.setAttribute(sunLine, "stroke-width", (daylight[i]-9.1)*2);
		SVG.setAttribute(sunLine, "stroke-width", (daylight[i]-9.1)*5);
		SVG.setAttribute(sunLine, "stroke-linecap", "round");
		SVG.setAttribute(sunLine, "stroke", "#ddd");
		sunLayer.appendChild(sunLine);
	}

	// draw planets
	let planetMinMax = planets.map((p, pi) => {
		let sorted = p.distance.slice().sort((a,b)=>a-b);
		return [sorted[0], sorted[sorted.length-1]];
	});
	let planetLines = planets.map((p, pi) => 
		p.longitude.map((l,li,arr) => {
			let radius = innerR + (outerR-innerR) * li/arr.length;
			return [Math.cos(l)*radius, Math.sin(l)*radius];
		})
	)
	// planetLines.forEach((p,i) =>{
	// 	let planetLine = SVG.polyline(p);
	// 	SVG.setAttribute(planetLine, "stroke", planets[i].color);
	// 	SVG.setAttribute(planetLine, "fill", "none");
	// 	SVG.setAttribute(planetLine, "stroke-width", 2);
	// 	planetsLayer.appendChild(planetLine);
	// });


	planetLines.reverse().forEach((p,piReverse,parr) => {
		let pi = parr.length - 1 - piReverse;
		let planetLayer = SVG.group();
		SVG.setAttribute(planetLayer, "id", planets[pi].name);

		p.forEach((point, i, arr) => {
			if(i == arr.length-1){ return; }
			let distance = 1.0 - (planets[pi].distance[i] - planetMinMax[pi][0]) / (planetMinMax[pi][1] - planetMinMax[pi][0])
			let planetWhite = SVG.line(arr[i][0], arr[i][1], arr[i+1][0], arr[i+1][1]);
			SVG.setAttribute(planetWhite, "stroke", "white");
			SVG.setAttribute(planetWhite, "stroke-linecap", "round");
			SVG.setAttribute(planetWhite, "stroke-width", 0.25 + 4*distance + 2);
			planetLayer.appendChild(planetWhite);
		});
		p.forEach((point, i, arr) => {
			if(i == arr.length-1){ return; }
			let distance = 1.0 - (planets[pi].distance[i] - planetMinMax[pi][0]) / (planetMinMax[pi][1] - planetMinMax[pi][0])
			let planetLine = SVG.line(arr[i][0], arr[i][1], arr[i+1][0], arr[i+1][1]);
			SVG.setAttribute(planetLine, "stroke", "black");
			SVG.setAttribute(planetLine, "stroke-linecap", "round");
			SVG.setAttribute(planetLine, "stroke-width", 0.25 + 4*distance);
			planetLayer.appendChild(planetLine);
		});
		planetsLayer.appendChild(planetLayer);
	});
	// console.log(planetMinMax);
	// let distance = planets[i].distan



	//// moon phases
	for(let i = 1; i < moonLongitude.length; i++) {
		for(let m = 0; m < 4; m++){
			let phase = -1;
			if(moonPhase[i-1] < moonEventAngles[m]
				&& moonEventAngles[m] < moonPhase[i]) {
				phase = m;
			}
			if(moonPhase[i-1] > 5.26 && moonPhase[i] < 1){
				phase = 0;
			}
			if(phase != -1){
				let radius = innerR + (outerR-innerR) * i / moonLongitude.length;
				let moonBack = SVG.circle( 
					Math.cos(moonLongitude[i]) * radius,
					Math.sin(moonLongitude[i]) * radius,
					4);
				SVG.setAttribute(moonBack, "fill", "white");
				SVG.setAttribute(moonBack, "stroke", "black");
				SVG.setAttribute(moonBack, "stroke-width", 1);
				dataLayer.appendChild(moonBack);
				// var r = (phase == 0) ? 2.75 : 4
				var r = 2.75;
				let moon = drawMoon( 
					Math.cos(moonLongitude[i]) * radius,
					Math.sin(moonLongitude[i]) * radius,
					r,
					phase);
				dataLayer.appendChild(moon);
			}
		}
	}




	let tStyleZodiac = "fill:black; font-family:Avenir Next; font-size:6px; text-anchor: middle;";
	zodiacNames.forEach((zodiac,i) => {
		let str = zodiac.toUpperCase();
		let text = SVG.text(str, 0, 0);
		let transform = "rotate("+(-i/12*360)+") translate(0 "+(-outerR - 11)+")"
		SVG.setAttribute(text, "style", tStyleZodiac);
		SVG.setAttribute(text, "transform", transform);
		noTiltLayer.appendChild(text);
	})

	let sortedLight = daylight
		.map((a,i)=>({a:a,i:i}))
		.sort((a,b)=>a.a-b.a)
		.map(el => el.i);
	let solstice = [sortedLight[0], sortedLight[ sortedLight.length-1 ]];
	// add equinoxes
	solstice.push( 7 + parseInt((solstice[1] - solstice[0]) / 2) + solstice[0]);
	solstice.push( -14+ parseInt(solstice[2] - daylight.length*0.5) );
	// those needed +/- 7 adjustment idk why
	solstice.forEach(i => {
		let calendarR = innerR + (outerR-innerR) * i / sunLongitude.length;
		let x = Math.cos(sunLongitude[i])*calendarR;
		let y = Math.sin(sunLongitude[i])*calendarR;
		let circle = SVG.circle(x, y, 10);
		SVG.setAttribute(circle, "stroke", "black");
		SVG.setAttribute(circle, "fill", "white");
		SVG.setAttribute(circle, "stroke-width", "2.5");
		dataLayer.appendChild(circle);
	});

	// font-weight:bold; 
	let textStyle = "fill: black; font-family: Avenir Next; font-size: 7px;";// text-anchor: middle;";
	[
		{r:0, text:"Solstice", i:solstice[0], angle: sunLongitude[solstice[0]]},
		{r:0, text:"Solstice", i:solstice[1]-4, angle: sunLongitude[solstice[1]]},
		{r:0, text:"Equinox", i:solstice[2], angle: sunLongitude[solstice[2]]},
		{r:10, text:"Equinox", i:solstice[3]-4, angle: sunLongitude[solstice[3]-1]},
		{r:-10, text:"Mercury retrograde", i:257, angle: mercuryLongitude[257]},
		{r:15, text:"Mercury direct", i:348, angle: mercuryLongitude[348]},
		{r:0, text:"Mercury retrograde", i:753, angle: mercuryLongitude[753]},
		{r:-7, text:"Mercury direct", i:850, angle: mercuryLongitude[850]},
		{r:15, text:"Mercury retrograde", i:1216, angle: mercuryLongitude[1216]},
		{r:0, text:"Mercury direct", i:1297, angle: mercuryLongitude[1297]},
		{r:7.5, text:"Mercury transit", i:1258, angle: mercuryLongitude[1258]},
		{r:10, text:"Jupiter retrograde", i:401, angle: jupiterLongitude[401]},
		{r:0, text:"Jupiter direct", i:892, angle: jupiterLongitude[892]},
		{r:10, text:"Saturn retrograde", i:474, angle: saturnLongitude[474]},
		{r:0, text:"Saturn direct", i:1040, angle: saturnLongitude[1040]},
		{r:-10, text:"Uranus direct", i:25, angle: uranusLongitude[25]},
		{r:10, text:"Uranus retrograde", i:890, angle: uranusLongitude[890]},
		{r:30, text:"Neptune retrograde", i:684, angle: neptuneLongitude[684]},
		{r:-5, text:"Neptune direct", i:1320, angle: neptuneLongitude[1320]},

	].forEach(el => {
		let str = el.text;//.toUpperCase();
		let s = "<tspan x='2px' dy='1.2em'>"+str+"</tspan><tspan x='2px' dy='1.1em'>"+indexToDate(el.i)+"</tspan>";
		let text = SVG.text(s, 0, 0);
		let r = outerR + 40 + el.r;
		let a = -el.angle/Math.PI*180+30;
		let transform = "rotate("+(a-90)+") translate(0 "+(-r)+")"
		SVG.setAttribute(text, "style", textStyle);
		SVG.setAttribute(text, "transform", transform);
		textLayer.appendChild(text);
		let l = SVG.line(
			Math.cos((a+180)/180*Math.PI)*(outerR+18),
			Math.sin((a+180)/180*Math.PI)*(outerR+18),
			Math.cos((a+180)/180*Math.PI)*(r-3),
			Math.sin((a+180)/180*Math.PI)*(r-3));
		SVG.setAttribute(l, "stroke", "#777");
		textLayer.appendChild(l);

	});

	function indexToDate(index){
		return month[index] + "." + day[index];
	}

});



function drawMoon(x, y, r, phase) {
	let tilt = 0.6;
	let moon;
	switch (phase){
		case 0:
			moon = SVG.circle(x, y, r);
			SVG.setAttribute(moon, "stroke", "none");
			// SVG.setAttribute(moon, "fill", "none");
			SVG.setAttribute(moon, "fill", "black");
			return moon;
		case 1:
			// moon = SVG.arc(x, y, r, (Math.PI*1.5)+tilt, (Math.PI*2.5)+tilt);
			moon = SVG.arc(x, y, r, (Math.PI*1.5)+tilt, (Math.PI*2.5)+tilt);
			SVG.setAttribute(moon, "stroke", "none");
			SVG.setAttribute(moon, "fill", "black");
			return moon;
		case 2:
			moon = SVG.circle(x, y, r);
			SVG.setAttribute(moon, "stroke", "none");
			// SVG.setAttribute(moon, "fill", "black");
			SVG.setAttribute(moon, "fill", "none");
			return moon;
		case 3:
			// moon = SVG.arc(x, y, r, (Math.PI*0.5)+tilt, (Math.PI*1.5)+tilt);
			moon = SVG.arc(x, y, r, (Math.PI*0.5)+tilt, (Math.PI*1.5)+tilt);
			SVG.setAttribute(moon, "stroke", "none");
			SVG.setAttribute(moon, "fill", "black");
			return moon;
	}
}


</script>